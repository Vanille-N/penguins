\section{Implementation}


\subsection{\ttt{Hex}}

Directions were renamed to be more intuitive, and they were removed
from the public interface to be accessible only through \ttt{all\_directions}
and the utility functions \ttt{opposite} as well as \ttt{neighbors}.\\

\ttt{read\_grid} was made to be robust : it is able to read problems even
if they contain extra lines before \ttt{<problem>} or after \ttt{</problem},
and it is able to adapt itself depending on the parity of the line which
features indentation.


\subsection{\ttt{Bitset}}

\ttt{Bitset.t} uses \ttt{Int64.t} as recommended, and makes use of
bitwise operators for good performance.\\

Internally it uses mutable objects to avoid unnecessary copies but it exposes
an immutable public interface.\\

Several utility functions were added to implement standard operations that benefit
from not repeatedly converting from and to \ttt{int} and from avoiding creating
copies.\\
Those are \ttt{setminus}, \ttt{union}, \ttt{intersect} which are self-explanatory
both in name and in implementation as well as the more complex
\ttt{transitive\_closure} which takes a starting point and a \ttt{elt -> elt list}
neighbor function and calculates the connected component of \ttt{start}.\\
\ttt{compare} is useful to sort sets by increasing cardinal.


\subsection{\ttt{Priority}}

\ttt{'a node} was made with a mutable key so that \ttt{decrease\_key} does
not invalidate the reference handed out during \ttt{insert}.\\
\ttt{find} searches the location of the node in the queue to be used with
\ttt{member} and \ttt{remove}. \ttt{find} does not unnecessarily explore
the rest of the heap when it finds a key greater than the one being searched,
but no effort has been invested into any further improvement of performance,
since the two functions \ttt{remove} and \ttt{decrease\_key} are useless for
my implementation.\\

\ttt{sift} and \ttt{trinkle} perform rotations rather than two-element permutations
for some performance gain.\\


